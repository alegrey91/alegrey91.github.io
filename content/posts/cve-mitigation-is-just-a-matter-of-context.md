+++ 
draft = true
date = 2025-12-18T15:42:47+01:00
title = "CVE mitigation is just a matter of context"
description = ""
slug = ""
authors = ["Alessio Greggi"]
tags = []
categories = []
externalLink = ""
series = []
+++

My last period at SUSE has been quite interesting. Last July, I moved to the SUSE Security team to help develop a new project for the security portfolio.

This project answer to the name of [SBOMscanner](github.com/kubewarden/sbomscanner), a SBOM-centric security scanner for registries, that has its lifecycle inside kubernetes.

One of the first features I've made was about supporting [VEX](https://www.cisa.gov/sites/default/files/publications/VEX_Use_Cases_Document_508c.pdf) repositories configuration (link [here](https://github.com/kubewarden/sbomscanner/pull/330)). Thanks to this task I had the chance of discovering this new standard format used to convey information about the exploitability of vulnerabilities in software products and share it with scanning tools.

Since there, I've been thinking about the possibility of generating VEX documents in order to reduce the noise of vulnerabilities in a way that doesn't require an extensive knowledge about security concepts. This ended up with a nice idea that I'm going to describe below.

## Introduction

VEX is commonly used to suppress vulnerabilities that are not affecting your application. This is usually a task for security experts or highly seasoned software engineers that well known the code base they are working on. A common example of this is when you have a vulnerability in a library that you are importing in your project, but you perfectly know that the vulnerable code in the library is not reachable from your application. This import would not be considered exploitable, since the project is not making use of the piece of code in the library which has this vulnerability.

Considering that, VEX comes into help to instruct the scanning tools (such as [Trivy](https://github.com/aquasecurity/trivy)) to skip the inclusion of that CVE in the final report, which are not actually affecting your code for known reasons.

My tought was quite simple, and involved the fact that vulnerabilities might be blocked by the environment the application is running on. A clear example of this, is when you run your application on a distrubuted system like Kubernetes. Kubernetes offers a nice way to define privilege and access control settings for a Pod or Container. This is possible by using the Security Context settings to define a deployment for your application. Here's an example:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-secure
  namespace: default
  labels:
    app: nginx
spec:
  template:
    spec:
      containers:
      - name: nginx
        image: nginx:1.21.0
        ports:
        - containerPort: 8080
          name: http
        # container-level security context
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
```

Just by setting `allowPrivilegeEscalation: false` and `readOnlyRootFilesystem: true`, we can sensitively reduce the attack surface of our running container. This leads to the blocking of some CVEs that require a writable file system or the ability to elevate privileges in order to exploit the system.

So, the Security Context looks like a valuable way to protect the application against certain **class** of CVEs. But, are CVEs actually classified in a way we can predict which Security Context should be applied in order to block them? The answer is quite complex, but apparently we could.

When a new vulnerability is discovered, in order to become a CVE, it must pass through a process of confirmation by the identification of the minimum required data elements for a CVE Record. Then the record is published to the CVE List with a unique ID. Trough this process, the vulnerability is also classified into one (or more) CWEs. [CWE](https://cwe.mitre.org/about/new_to_cwe.html) stands for Common Weakness Enumeration, and is a category system for hardware and software weaknesses and vulnerabilities.

Looking at this example [CVE-2021-36159](https://nvd.nist.gov/vuln/detail/CVE-2021-36159), we can see it has been categorized as an "Out-of-bounds Read" vulnerability ([CWE-125](https://cwe.mitre.org/data/definitions/125.html)).

As a next step, I had to rack my brain and map CWEs to a set of Security Context settings able to block or reduce the vulnerability impact. I'm not going to explain each of them in dept, but I'll just leave a link to the code that implements this concept of [mitigation](https://github.com/alegrey91/vex8s/blob/main/pkg/mitigation/mitigation.go) by Security Context, since this might change over time. In general, each CWE class has a set rules that must match the workload deployment configuration. If the rules match, then we can consider the CVE mitigated using the Kubernetes Security Context.

---

The idea is based on the following concepts:

**Each CVE is categorized into one or more vulnerability classes (CWE)**. [CWE](https://cwe.mitre.org/about/new_to_cwe.html) (Common Weakness Enumeration) is meant as a class of vulnerability to be assigned to a CVE. Each CVE, in order to be published, needs to be classified into a class. This simplifies the triaging and the patching of the CVE itself.

**Each class maps to a set of Kubernetes securityContext settings that can block or reduce the impact**. Knowing the CWE, we might find a list of rules to identify if the CVE is mitigable or not. In the context of Kubernetes, we have a several configurations we can apply to a workload in order to harden its surface and possibly, block certain vulnerabilities. These configurations, to point out, are the [`SecurityContexts`](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).

**By parsing a kubernetes manifest, we can inspect the container `SecurityContext` to evaluate whether the relevant settings are in place**. Combining the workload manifest (used to deploy on kubernetes) and the list of CVE found on the container image being deployed, we can identify which of the CVEs are actually. 

**If it results in a CVE mitigation, we add this to the final VEX document**. Eventually, we collect all the mitigable CVEs in a list that we convert into a VEX file. This file will be later used by the security scanning tool that previously generated the vulnerability report. This time, the result will have less false positives.

## Sources

https://www.aquasec.com/cloud-native-academy/vulnerability-management/vulnerability-exploitability-exchange/

