+++ 
draft = true
date = 2025-12-18T15:42:47+01:00
title = "CVE mitigation is just a matter of context"
description = ""
slug = ""
authors = ["Alessio Greggi"]
tags = []
categories = []
externalLink = ""
series = []
+++

My last period at SUSE has been quite interesting. Last July, I moved to the SUSE Security team to help develop a new project for the security portfolio.

This project answer to the name of [SBOMscanner](github.com/kubewarden/sbomscanner), a SBOM-centric security scanner for registries, that has its lifecycle inside kubernetes.

One of the first features I've made was about supporting [VEX](https://www.cisa.gov/sites/default/files/publications/VEX_Use_Cases_Document_508c.pdf) repositories configuration (link [here](https://github.com/kubewarden/sbomscanner/pull/330)). Thanks to this task I had the chance of discovering this new standard format used to convey information about the exploitability of vulnerabilities in software products and share it with scanning tools.

Since there, I've been thinking about the possibility of generating VEX documents in order to reduce the noise of vulnerabilities in a way that doesn't require an extensive knowledge about security concepts. This ended up with a nice idea that I'm going to describe below.

## Introduction

VEX is commonly used to suppress vulnerabilities that are not affecting your application. This is usually a task for security experts or highly seasoned software engineers that well known the code base they are working on. A common example of this is when you have a vulnerability in a library that you are importing in your project, but you perfectly know that the vulnerable code in the library is not reachable from your application. This import would not be considered exploitable, since the project is not making use of the piece of code in the library which has this vulnerability.

Considering that, VEX comes into help to instruct the scanning tools (such as [Trivy](https://github.com/aquasecurity/trivy)) to skip the inclusion of that CVE in the final report, which are not actually affecting your code for known reasons.

My tought was quite simple, and involved the fact that vulnerabilities might be blocked by the environment the application is running on. A clear example of this, is when you run your application on a distrubuted system like Kubernetes. Kubernetes offers a nice way to define privilege and access control settings for a Pod or Container. This is possible by using the Security Context settings to harden the deployment for your application. Here's an example:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-secure
  namespace: default
  labels:
    app: nginx
spec:
  template:
    spec:
      containers:
      - name: nginx
        image: nginx:1.21.0
        ports:
        - containerPort: 8080
          name: http
        # container-level security context
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
```

Just by setting `allowPrivilegeEscalation: false` and `readOnlyRootFilesystem: true`, we can sensitively reduce the attack surface of our running container. This leads to the blocking of some CVEs that require a writable file system or the ability to elevate privileges in order to exploit the system.

So, the Security Context looks like a valuable way to protect the application against certain **class** of CVEs. But, are CVEs actually classified in a way we can predict which Security Context should be applied in order to block them? The answer is quite complex, but apparently we could.

When a new vulnerability is discovered, in order to become a CVE, it must pass through a process of confirmation by the identification of the minimum required data elements for a CVE Record. Then the record is published to the CVE List with a unique ID. Trough this process, the vulnerability is also classified into one (or more) CWEs. [CWE](https://cwe.mitre.org/about/new_to_cwe.html) stands for Common Weakness Enumeration, and is a category system for hardware and software weaknesses and vulnerabilities.

Looking at this example [CVE-2021-36159](https://nvd.nist.gov/vuln/detail/CVE-2021-36159), we can see it has been categorized as an "Out-of-bounds Read" vulnerability ([CWE-125](https://cwe.mitre.org/data/definitions/125.html)).

As a next step, I had to rack my brain and map CWEs to a set of Security Context settings able to block or reduce the vulnerability impact. I'm not going to explain each of them in dept, but I'll just leave a link to the code that implements this concept of [mitigation](https://github.com/alegrey91/vex8s/blob/main/pkg/mitigation/mitigation.go) by Security Context, since this might change over time. In general, each CWE class has a set rules that must match the workload deployment configuration. If the rules match, then we can consider the CVE mitigated using the Kubernetes Security Context.

Let's take as example the mitigation rule for [CWE-732](https://cwe.mitre.org/data/definitions/732.html) (Incorrect Permission Assignment for Critical Resource).
Suppose that a CVE with this CWE classification is found. For instance, let's take under considation the [CVE-2022-42972](https://nvd.nist.gov/vuln/detail/CVE-2022-42972). As the description of the CVE says: *"A CWE-732: Incorrect Permission Assignment for Critical Resource vulnerability exists that could cause local privilege escalation when a local attacker modifies the webroot directory."*. Having the file system and volume mounts in read-only mode we should be pretty comfortable that the vulnerability wont be exploited since there's no way to modify the webroot directory in read-only mode.
Consequently, the settings able to mitigate this CVE translate into something like this:
 
* `readOnlyRootFilesystem: true`
* `volumeMounts[].readOnly: true`

We can now parse the workload manifest to evaluate wheter the relevant settings are in place. If we find CVEs that are mitigated by the manifest configuration, we can add them in the VEX document to inform the scanning tool to not consider those CVEs in the final report.

## Sources

https://www.aquasec.com/cloud-native-academy/vulnerability-management/vulnerability-exploitability-exchange/

