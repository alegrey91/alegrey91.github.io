+++ 
draft = true
date = 2025-12-18T15:42:47+01:00
title = "CVE mitigation is just a matter of context"
description = ""
slug = ""
authors = ["Alessio Greggi"]
tags = []
categories = ["security"]
externalLink = ""
series = []
+++

My last period at SUSE has been quite interesting. Last July, I moved to the SUSE Security team to help develop a new project for the security portfolio.

This project goes by the name of [SBOMscanner](https://github.com/kubewarden/sbomscanner): an SBOM-centric security scanner for container registries, designed to run natively inside Kubernetes.

One of the first features I worked on was support for configuring [VEX](https://www.cisa.gov/sites/default/files/publications/VEX_Use_Cases_Document_508c.pdf) repositories (PR [here](https://github.com/kubewarden/sbomscanner/pull/330)). Thanks to this task, I had the chance to discover this relatively new standard format, which is used to convey information about the exploitability of vulnerabilities in software products and to share that information with scanning tools.

From there, I started thinking about the possibility of *generating* VEX documents automatically, with the goal of reducing vulnerability noise in a way that doesn't require deep security expertise. This line of thought eventually led to an idea that I'd like to describe below.

## Introduction

VEX is commonly used to suppress vulnerabilities that do not actually affect your application. This task is usually performed by security experts or very experienced software engineers who know the codebase inside out.

A common example is a vulnerability found in a library that your project depends on, where you know for sure that the vulnerable code path is not reachable from your application. In this case, the vulnerability is not exploitable, even though the library is technically affected.

VEX helps in this scenario by instructing scanning tools (such as [Trivy](https://github.com/aquasecurity/trivy)) to exclude those CVEs from the final report when there are known and documented reasons why they are not relevant.

## Idea

My thought was relatively simple: some vulnerabilities may be effectively blocked by the *environment* in which an application is running.

A clear example is an application deployed on a distributed system like Kubernetes. Kubernetes provides powerful mechanisms to define privilege and access control settings for Pods and containers through **Security Contexts**, allowing you to harden workloads at deployment time.

Here's a simple example:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-secure
  namespace: default
  labels:
    app: nginx
spec:
  template:
    spec:
      containers:
      - name: nginx
        image: nginx:1.21.0
        ports:
        - containerPort: 8080
          name: http
        # container-level security context
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
```

By setting `allowPrivilegeEscalation: false` and `readOnlyRootFilesystem: true`, we can significantly reduce the attack surface of the running container. As a result, some CVEs that require a writable filesystem or the ability to escalate privileges become much harder, or impossible to exploit.

This naturally leads to the idea that Kubernetes Security Contexts can protect applications from certain classes of vulnerabilities. But are CVEs actually classified in a way that allows us to reason about this systematically? The answer is complex, but to some extent, yes.

When a new vulnerability is discovered and assigned a CVE, it goes through a validation process that includes identifying a set of required data elements for the CVE record. During this process, the vulnerability is also classified into one or more CWEs. [CWE](https://cwe.mitre.org/about/new_to_cwe.html) stands for Common Weakness Enumeration and represents a categorization system for hardware and software weaknesses.

For example, [CVE-2021-36159](https://nvd.nist.gov/vuln/detail/CVE-2021-36159) is classified as an Out-of-bounds Read vulnerability, corresponding to [CWE-125](https://cwe.mitre.org/data/definitions/125.html).

At this point, the challenge was to map specific CWE classes to a set of Kubernetes Security Context settings that could mitigate or reduce their impact. I’m not going to explain each mapping in depth here, as this logic may evolve over time, but you can find the current implementation in the codebase [here](https://github.com/alegrey91/vex8s/blob/main/pkg/mitigation/mitigation.go).

In general, each CWE class is associated with a set of rules that are evaluated against the workload’s deployment configuration. If the rules match, the corresponding CVE can be considered mitigated by the Kubernetes Security Context.

Let’s take [CWE-732](https://cwe.mitre.org/data/definitions/732.html) (Incorrect Permission Assignment for Critical Resource) as an example.

Consider [CVE-2022-42972](https://nvd.nist.gov/vuln/detail/CVE-2022-42972), whose description states: *"A CWE-732: Incorrect Permission Assignment for Critical Resource vulnerability exists that could cause local privilege escalation when a local attacker modifies the webroot directory."*

If both the filesystem and the volume mounts are configured as read-only, we can be reasonably confident that this vulnerability cannot be exploited, as there is no way to modify the webroot directory.

The Security Context settings that mitigate this CVE would therefore look like:

* `readOnlyRootFilesystem: true`
* `volumeMounts[].readOnly: true`

At this point, it becomes possible to parse the workload manifest and evaluate whether the relevant settings are in place. If a CVE is deemed mitigated by the deployment configuration, it can be added to a VEX document, informing the scanner that it should not be included in the final vulnerability report.

## Limitations

This approach is not without limitations, and it is important to be clear about its boundaries.

First, the mapping between CWE classes and Kubernetes Security Context settings is inherently heuristic. CWEs are often broad categories, and not all vulnerabilities within the same CWE can be mitigated in the same way. This means that false positives (considering a CVE mitigated when it is not) are possible if the rules are too permissive.

Second, this method only considers what can be inferred from the deployment manifest. It does not account for runtime behavior, misconfigurations outside Kubernetes (e.g. node-level settings), or vulnerabilities that can be exploited without violating the constraints imposed by the Security Context.

Finally, this approach should not be seen as a replacement for manual security analysis. Instead, it should be treated as a way to reduce noise and prioritize findings, especially in large environments where the volume of reported vulnerabilities can be overwhelming.

## Conclusion

Automatically generating VEX documents based on Kubernetes Security Contexts offers an interesting opportunity to bridge the gap between application security and platform security.

By leveraging existing deployment hardening measures, it becomes possible to suppress vulnerabilities that are already mitigated by design, reducing alert fatigue and allowing teams to focus on issues that truly matter. This is particularly valuable in Kubernetes environments, where security controls are often expressed declaratively and can be analyzed statically.

While this approach has clear limitations and must be applied carefully, it demonstrates how contextual information, such as workload configuration can significantly improve the quality of vulnerability reporting. In the long term, combining SBOMs, VEX, and platform-aware analysis could help make vulnerability management more accurate, scalable, and accessible, even for teams without deep security expertise.

## Sources

https://www.aquasec.com/cloud-native-academy/vulnerability-management/vulnerability-exploitability-exchange/

